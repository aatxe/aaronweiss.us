<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Aaron Weiss / Recent Posts</title>
        <link>https://aaronweiss.us</link>
        <description><![CDATA[Personal blog of Aaron Weiss]]></description>
        <atom:link href="https://aaronweiss.us/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 26 Feb 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Reasoning with Types in Rust</title>
    <link>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html</link>
    <description><![CDATA[<p><a href="https://www.rust-lang.org/">Rust</a> is a modern programming language which is marketed primarily on the basis of its very nice type system, and I’d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called <a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html"><em>fearless concurrency</em></a> (and rightfully so—this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:</p>
<blockquote>
<p>From the type of a polymorphic function we can derive a theorem that it satisfies. Every function of the same type satisfies the same theorem. This provides a free source of useful theorems.</p>
<p><cite>Philip Wadler, <a href="http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf"><em>Theorems for Free!</em></a></cite></p>
</blockquote>
<p>If you’re not the most mathematically inclined, don’t be scared off by the word theorem! The quote is telling us that—with the right property of our type system—we can learn useful properties about generic (i.e. polymorphic) functions solely by inspecting their types. In the rest of this post, we’ll cover this type system property, and a number of example properties we can derive from types as as result.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> Much of what’s covered can be generalized to languages aside from Rust, but (most) examples will be in Rust with Rust-specific aspects highlighted.</p>
<h1 id="a-principal-property-for-reasoning">A Principal Property for Reasoning</h1>
<p>The property at the heart of this style of type-based reasoning with generics is known as <em>parametricity</em>. Parametricity can be formulated as a mathematical theorem,<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> but it’s best thought of intuitively as the notion that all instances of a polymorphic function act the same way. With this intuition in mind, you can imagine determining whether or not a particular function is parametric. For example, we can determine that the following <a href="https://www.java.com/">Java</a> function is parametric:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">public</span> <span class="dt">static</span> &lt;T&gt; T <span class="fu">identity</span>(T x) {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">return</span> x;</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>And that the following almost-Java function is not:<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">public</span> <span class="dt">static</span> &lt;T&gt; T <span class="fu">notIdentity</span>(T x) {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">if</span> (x <span class="kw">instanceof</span> <span class="bu">Integer</span>) {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">return</span> (T) <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="kw">return</span> x;</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">}</a></code></pre></div>
<p>The reason for this is that the latter function has chosen to specialize its behavior based on the type of its parameter, rather than acting the same on all types. This cuts to the essence of parametricity: to write parametric functions, we must treat parametric types opaquely! While Java does not enforce parametricity (and in fact often encourages otherwise), other type systems like that of <a href="https://www.haskell.org/">Haskell</a> and Rust require all functions to be parametric.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> When all polymorphic functions are parametric, the type system is said to be <em>parametrically polymorphic</em>—though in practice, many parametrically polymorphic type systems support some degree of ad hoc (that is, type-dependent polymorphism). In this case, we know that all polymorphic functions are parametric and we’re able to learn some of their properties solely from their type. So, let’s look at some examples in Rust.</p>
<h1 id="who-am-i-or-reasoning-about-identity">Who am I? or: Reasoning about Identity</h1>
<p>Consider the following function type, and try to imagine as many implementations as possible:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">fn</span>&lt;T&gt;(T) -&gt; T</a></code></pre></div>
<p>This type describes a function that for any type <code class="sourceCode rust">T</code>, takes an argument of type <code class="sourceCode rust">T</code> and returns a result of type <code class="sourceCode rust">T</code>. If you’re already familiar with Rust, I’m sure it wouldn’t take long to come up with the following implementation, the identity function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">fn</span> id&lt;T&gt;(x: T) -&gt; T <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    x</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="op">}</span></a></code></pre></div>
<p>In fact, since there are no operations we can actually perform on <code class="sourceCode rust">x</code>, it’s the only possible return value for this function. Of course, since Rust is effectful, we could print something before we return like so:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">fn</span> effectful_id&lt;T&gt;(x: T) -&gt; T <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="pp">println!</span>(<span class="st">&quot;oh no&quot;</span>);</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    x</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="op">}</span></a></code></pre></div>
<p>And Rust is also partial, meaning we could error (called <em>panicking</em> in Rust) or otherwise diverge:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">fn</span> panicking_id&lt;T&gt;(_: T) -&gt; T <span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="pp">panic!</span>(<span class="st">&quot;at the disco&quot;</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">pub</span> <span class="kw">fn</span> diverging_id&lt;T&gt;(_: T) -&gt; T <span class="op">{</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">loop</span> <span class="op">{}</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="op">}</span></a></code></pre></div>
<p>These various implementations all tell us something about what the type means, which we can phrase like so:</p>
<blockquote>
<p>A function of type <code class="sourceCode rust"><span class="kw">fn</span>&lt;T&gt;(T) -&gt; T</code> must:</p>
<ul>
<li>return its argument <strong>or</strong></li>
<li>panic or abort <strong>or</strong></li>
<li>never return</li>
</ul>
</blockquote>
<p>Additionally, since we still know nothing about the type <code class="sourceCode rust">T</code>, we can conclude that any effects that occur during the function are <em>not</em> dependent on the argument. With these two properties, we can then conclude the more general properties that functions of the type <code class="sourceCode rust"><span class="kw">fn</span>&lt;T&gt;(T) -&gt; T</code> behave “like an identity function”:</p>
<blockquote>
<p>Given a function <code class="sourceCode rust">id</code> of type <code class="sourceCode rust"><span class="kw">fn</span>&lt;T&gt;(T) -&gt; T</code>, a total function <code class="sourceCode rust">f</code> of the form <code class="sourceCode rust"><span class="kw">fn</span>(A) -&gt; B</code> where <code class="sourceCode rust">A</code> and <code class="sourceCode rust">B</code> are both concrete types, and a value <code class="sourceCode rust">a</code> of type <code class="sourceCode rust">A</code>, then either:</p>
<ul>
<li><code class="sourceCode rust">id</code> can be composed arbitrarily (e.g. <code class="sourceCode rust">id(f(a)) = f(id(a))</code>) <strong>or</strong></li>
<li><code class="sourceCode rust">id(f(a))</code> and <code class="sourceCode rust">f(id(a))</code> both panic or diverge.</li>
</ul>
</blockquote>
<p>In order to conclude this, we can consider each of the cases we previously described. If the function returns its argument, then we know both that <code class="sourceCode rust">id(a) = a</code> and <code class="sourceCode rust">id(f(a)) = f(a)</code> and we can combine these two equalities to conclude the first result. If the function does not return its arguments, we know it either panics or never returns but we also know that this cannot be dependent on the argument in any way. Thus if <code class="sourceCode rust">id(f(a))</code> panics, then <code class="sourceCode rust">f(id(a))</code> <strong>must</strong> panic as well.</p>
<p>With that, we’ve intuited (but have not formally proven)<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> our first “useful theorem” about a family of functions based solely on their type. While it’s nice to know that identity-looking functions behave like an identity function, there’s certainly nothing earth-shattering about the result. But the fact that we can apply this style of reasoning to <em>every</em> type ought to be compelling.</p>
<h1 id="vectors-abound">Vectors Abound</h1>
<p>Let’s look at a slightly more complicated type now, involving Rust’s <code class="sourceCode rust"><span class="dt">Vec</span>&lt;T&gt;</code> type for dynamically-sized buffers. We’ll again follow the same formula of enumerating some possible implementations before trying to conclude a general property. Given the type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">fn</span>&lt;T&gt;(<span class="dt">Vec</span>&lt;T&gt;) -&gt; <span class="dt">Vec</span>&lt;T&gt;</a></code></pre></div>
<p>We can come up with implementations such as:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">fn</span> tail&lt;T&gt;(vec: <span class="dt">Vec</span>&lt;T&gt;) -&gt; <span class="dt">Vec</span>&lt;T&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    vec.into_iter().skip(<span class="dv">1</span>).collect()</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">pub</span> <span class="kw">fn</span> reverse&lt;T&gt;(vec: <span class="dt">Vec</span>&lt;T&gt;) -&gt; <span class="dt">Vec</span>&lt;T&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="kw">let</span> init = <span class="dt">Vec</span>::with_capacity(vec.capacity());</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    vec.into_iter().fold(init, |<span class="kw">mut</span> acc, elem| <span class="op">{</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        acc.insert(<span class="dv">0</span>, elem);</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">        acc</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    <span class="op">}</span>)</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="op">}</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="kw">pub</span> <span class="kw">fn</span> swap_first_two&lt;T&gt;(<span class="kw">mut</span> vec: <span class="dt">Vec</span>&lt;T&gt;) -&gt; <span class="dt">Vec</span>&lt;T&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    <span class="kw">if</span> vec.len() &lt; <span class="dv">2</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        <span class="kw">return</span> vec;</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="kw">let</span> elem = vec.remove(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">    vec.insert(<span class="dv">0</span>, elem);</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">    vec</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="op">}</span></a></code></pre></div>
<p>We can then try to capture a sense of what this type means as we did before:</p>
<blockquote>
<p>A function <code class="sourceCode rust">m</code> (for mystery) of type <code class="sourceCode rust"><span class="kw">fn</span>&lt;T&gt;(<span class="dt">Vec</span>&lt;T&gt;) -&gt; <span class="dt">Vec</span>&lt;T&gt;</code> must:</p>
<ul>
<li>return a <code class="sourceCode rust"><span class="dt">Vec</span>&lt;T&gt;</code> that contains a subset of the contents of its argument <code class="sourceCode rust"><span class="dt">Vec</span>&lt;T&gt;</code> in any order. (i.e. <code class="sourceCode agda">∀v<span class="ot">.</span> <span class="ot">{</span>e <span class="ot">|</span> e ∈ m<span class="ot">(</span>v<span class="ot">)}</span> ⊆ <span class="ot">{</span>e <span class="ot">|</span> e ∈ v<span class="ot">}</span></code>) <strong>or</strong></li>
<li>panic or abort <strong>or</strong></li>
<li>never return</li>
</ul>
</blockquote>
<p>The process of concluding this is more complicated, but the general gist is that such a function can only perform the operations defined on <code class="sourceCode rust"><span class="dt">Vec</span>&lt;T&gt;</code> and as usual cannot inspect the types of its elements. From there, we know that we cannot create new values of type <code class="sourceCode rust">T</code> or perform any operations dependent on values within the vector. This also leverages the Rust-specific fact that values (in this case, of type <code class="sourceCode rust">T</code>) cannot be copied without knowing that they implement <code class="sourceCode rust"><span class="bu">Clone</span></code> and/or <code class="sourceCode rust"><span class="bu">Copy</span></code> (whereas in other languages with parametricity, this typically is not the case). We can then conclude that all functions at this type must yield a permutation (or possibly a subset of a permutation) of the input vector. Of course, the same exceptions about panics and divergence apply. Interestingly, we can reach a similar general conclusion to the one we reached for <code class="sourceCode rust"><span class="kw">fn</span>&lt;T&gt;(T) -&gt; T</code>:</p>
<blockquote>
<p>Given a function <code class="sourceCode rust">m</code> of type <code class="sourceCode rust"><span class="kw">fn</span>&lt;T&gt;(<span class="dt">Vec</span>&lt;T&gt;) -&gt; <span class="dt">Vec</span>&lt;T&gt;</code>, a total function <code class="sourceCode rust">f</code> of the form <code class="sourceCode rust"><span class="kw">fn</span>(<span class="dt">Vec</span>&lt;A&gt;) -&gt; <span class="dt">Vec</span>&lt;B&gt;</code> where <code class="sourceCode rust">A</code> and <code class="sourceCode rust">B</code> are both concrete types, and <code class="sourceCode rust">a</code> is a value of type <code class="sourceCode rust"><span class="dt">Vec</span>&lt;A&gt;</code>, then either:</p>
<ul>
<li><code class="sourceCode rust">mystery(map_f(a)) = map_f(mystery(a))</code> where <code class="sourceCode rust">map_f</code> is defined as <code class="sourceCode rust">|x| <span class="op">{</span> x.iter().map(f).collect() <span class="op">}</span></code> <strong>or</strong></li>
<li>at least one of <code class="sourceCode rust">mystery(f(a))</code> and <code class="sourceCode rust">f(mystery(a))</code> panic or diverge.</li>
</ul>
</blockquote>
<h1 id="noninterference-for-free">Noninterference for Free</h1>
<p>Thus far, we’ve looked at rather simple properties of programs because it is easier to imagine the proof in your head. But now, let’s take the opportunity to explore a security property called <em>noninterference</em> for which a number of tailored type systems have been built. The idea behind these type systems is typically that you annotate types and values in your program with labels indicating whether a value should be public or secret (some systems expand this with further labels, but just the two are enough for the basics). Noninterference then says that functions with public output cannot depend on private inputs. Fortunately, using parametricity, we can have this property for free in Rust!<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<p>To do so, first, we have to define a notion of secret (we’ll treat all unannotated types as public, though we could choose to introduce a public type as well for symmetry):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">struct</span> Secret&lt;T&gt;(T);</a></code></pre></div>
<p>Strictly speaking, we’ve now achieved noninterference! That was probably easier than you expected, but the intuition should be clear: since we can perform no operations whatsoever on values of the type <code class="sourceCode rust">Secret&lt;T&gt;</code>, it is impossible for public outputs to depend on secret data! However, there is a caveat: because of how access modifiers work in Rust, code in the same module can violate noninterference like so:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">struct</span> Secret&lt;T&gt;(T);</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">pub</span> <span class="kw">fn</span> unwrap_secret&lt;T&gt;(secret: Secret&lt;T&gt;) -&gt; T <span class="op">{</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    secret.<span class="dv">0</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="op">}</span></a></code></pre></div>
<p>To avoid this, we can place our implementation of secret types inside of its own module with no additional code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">mod</span> secret <span class="op">{</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="kw">pub</span> <span class="kw">struct</span> Secret&lt;T&gt;(T);</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">use</span> <span class="kw">self</span>::secret::Secret;</a></code></pre></div>
<p>Now, we have noninterference enforced in any downstream code, but in real security type systems, you can still use secret values to compute other secret values. To do this, we can use Rust’s trait system to add common functionality. We can use this to define a lot of operations, but some of the operator-overloading traits (<code class="sourceCode rust">std::ops</code>) are not currently general enough making some code less pleasant.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> Here is our example with some ability to use secret values to compute other secret values:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">mod</span> secret <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Copy</span><span class="at">,</span> <span class="bu">Clone</span><span class="at">,</span> <span class="bu">Default</span><span class="at">)]</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="kw">pub</span> <span class="kw">struct</span> Secret&lt;T&gt;(T);</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="kw">use</span> std::ops::<span class="op">{</span>Add, Sub<span class="op">}</span>;</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    <span class="kw">impl</span>&lt;T&gt; Add <span class="kw">for</span> Secret&lt;T&gt; <span class="kw">where</span> T: Add <span class="op">{</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        <span class="kw">type</span> Output = Secret&lt;&lt;T <span class="kw">as</span> Add&gt;::Output&gt;;</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        <span class="kw">fn</span> add(<span class="kw">self</span>, other: Secret&lt;T&gt;) -&gt; <span class="kw">Self</span>::Output <span class="op">{</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">            Secret(<span class="kw">self</span>.<span class="dv">0</span> + other.<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">        <span class="op">}</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">    <span class="kw">impl</span>&lt;T&gt; Sub <span class="kw">for</span> Secret&lt;T&gt; <span class="kw">where</span> T: Sub <span class="op">{</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">        <span class="kw">type</span> Output = Secret&lt;&lt;T <span class="kw">as</span> Sub&gt;::Output&gt;;</a>
<a class="sourceLine" id="cb12-17" data-line-number="17"></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">        <span class="kw">fn</span> sub(<span class="kw">self</span>, other: Secret&lt;T&gt;) -&gt; <span class="kw">Self</span>::Output <span class="op">{</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19">            Secret(<span class="kw">self</span>.<span class="dv">0</span> - other.<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">        <span class="op">}</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">    <span class="op">}</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22"></a>
<a class="sourceLine" id="cb12-23" data-line-number="23">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24"><span class="op">}</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25"><span class="kw">use</span> <span class="kw">self</span>::secret::Secret;</a></code></pre></div>
<p>Now, we have some ways of using our secret data to construct other secret data. It’s limited, but many other extensions should follow similar patterns and we could also add other operations implemented directly on <code class="sourceCode rust">Secret&lt;T&gt;</code> types that compose secret values without going through a trait like so:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">impl</span> Secret&lt;<span class="dt">bool</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    <span class="kw">pub</span> <span class="kw">fn</span> branch&lt;F, T&gt;(&amp;<span class="kw">self</span>, cons: F, alt: F) -&gt; Secret&lt;T&gt;</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">where</span> F: <span class="bu">Fn</span>() -&gt; Secret&lt;T&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">        <span class="kw">if</span> <span class="kw">self</span>.<span class="dv">0</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">            cons()</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">            alt()</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">        <span class="op">}</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="op">}</span></a></code></pre></div>
<p>With all these extensions, the argument that parametricity is still enforcing noninterference is now dependent on the exact set of operations that have been implemented for <code class="sourceCode rust">Secret&lt;T&gt;</code>, but as long as they <em>always</em> return an argument of the form <code class="sourceCode rust">Secret&lt;T&gt;</code>, Rust will enforce noninterference. We can even include operations that combine <code class="sourceCode rust">Secret&lt;T&gt;</code> and <code class="sourceCode rust">T</code> as long as their results are themselves secret. We could even imagine building a simple static analysis tool that runs atop Rust to audit a crate providing such a secret type to ensure that every function it implements returns a secret marked type.</p>
<h1 id="bountiful-properties-with-bounded-parametricity">Bountiful Properties with Bounded Parametricity</h1>
<p>Though we used traits to extend the functionality of our <code class="sourceCode rust">Secret&lt;T&gt;</code> type, they played a somewhat limited role in our argument for noninterference via parametricity, but we can do more. Fundamentally, traits allow us to bound type parameters with a specific interface that can be used within functions. This allow us to weaken our notion of parametricity from type parameters and values at those types being completely opaque to values at those types being usable in a controlled fashion. Correspondingly, we can derive even more interesting properties from the types. For a simple example, consider this extended version of our original identity example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">fn</span>&lt;T&gt;(T) -&gt; T <span class="kw">where</span> T: <span class="bu">Display</span></a></code></pre></div>
<p>Previously, we said that any side-effects of this function could not depend on the argument. By adding the <code class="sourceCode rust"><span class="bu">Display</span></code> bound on <code class="sourceCode rust">T</code>, we’ve allowed the argument to be displayed in output effects like <code class="sourceCode rust"><span class="pp">println!</span></code>. In a sense, this new ability to display the argument is expanding the allowed set of side-effects. This expansion is most evident from the fact that all of our old implementations are still legal at this bounded type, but new implementations are also legal. For example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">fn</span> trace&lt;T&gt;(x: T) -&gt; T <span class="kw">where</span> T: <span class="bu">Display</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    x</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="op">}</span></a></code></pre></div>
<p>You may have noticed as we went through our earlier noninterference example that this property seems almost useless by virtue of being overly strict. In particular, since public outputs cannot depend on secret values in any way, there’s really no reason to use secret values at all. In practice, security type systems offer escape hatches (much like Rust’s <code class="sourceCode rust"><span class="kw">unsafe</span></code>) to selectively reveal secret information in a way that is readily auditable. With traits, we can build a principled escape hatch giving us a weakened property known as <em>relaxed noninterference</em>.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> Relaxed noninterference can be understood intuitively as the property that public outputs can only depend on secret values according to predetermined rules known as <em>declassification policies</em>.</p>
<p>In our formulation in Rust, we will record these policies as traits and use trait bounds to decide what policies are available within a function. Consequently, the type signatures of our functions will necessarily have to tell us how they plan on using the secret data we give them giving us strong, local reasoning principles for security. At the heart of this approach is our previous definition of <code class="sourceCode rust">Secret&lt;T&gt;</code> with a trait representing the empty declassification policy:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">struct</span> Secret&lt;T&gt;(T);</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">pub</span> <span class="kw">trait</span> Sec&lt;T&gt;: private::Sealed <span class="op">{}</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="kw">impl</span>&lt;T&gt; Sec&lt;T&gt; <span class="kw">for</span> Secret&lt;T&gt; <span class="op">{}</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="kw">mod</span> private <span class="op">{</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    <span class="kw">use</span> <span class="kw">super</span>::Secret;</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    <span class="kw">pub</span> <span class="kw">trait</span> Sealed <span class="op">{}</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    <span class="kw">impl</span>&lt;T&gt; Sealed <span class="kw">for</span> Secret&lt;T&gt; <span class="op">{}</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="op">}</span></a></code></pre></div>
<p>Our private module here is used to seal the <code class="sourceCode rust">Sec&lt;T&gt;</code> trait preventing it from being implemented on any additional types beyond <code class="sourceCode rust">Secret&lt;T&gt;</code>. With just this, we can now specify functions like before that have noninterference:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">fn</span> f&lt;S, T&gt;(x: <span class="dt">u32</span>, y: S) -&gt; <span class="dt">u32</span> <span class="kw">where</span> S: Sec&lt;<span class="dt">u32</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    <span class="co">// the following line is not legal...</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    <span class="co">// return y.0;</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    x</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="op">}</span></a></code></pre></div>
<p>We can then specify a number of declassification policies that enable us to make selective use of our secret values:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">// Debug declassification policy: can format the value for debugging purposes</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">impl</span>&lt;T&gt; <span class="bu">Debug</span> <span class="kw">for</span> Secret&lt;T&gt; <span class="kw">where</span> T: <span class="bu">Debug</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    <span class="kw">fn</span> fmt(&amp;<span class="kw">self</span>, f: &amp;<span class="kw">mut</span> Formatter) -&gt; <span class="dt">Result</span>&lt;(), Error&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">        <span class="kw">self</span>.<span class="dv">0.f</span>mt(f)</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="co">// Zeroable declassification policy: can determine whether or not this is zero</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9"><span class="kw">impl</span>&lt;T&gt; Zeroable <span class="kw">for</span> Secret&lt;T&gt; <span class="kw">where</span> T: Zeroable <span class="op">{</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">    <span class="kw">fn</span> is_zero(&amp;<span class="kw">self</span>) -&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">        <span class="kw">self</span>.<span class="dv">0.</span>is_zero()</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"><span class="op">}</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14"></a>
<a class="sourceLine" id="cb18-15" data-line-number="15"><span class="co">// Hash declassification policy: can compute a hash of the value</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16"><span class="kw">impl</span>&lt;T&gt; <span class="bu">Hash</span> <span class="kw">for</span> Secret&lt;T&gt; <span class="kw">where</span> T: <span class="bu">Hash</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">    <span class="kw">fn</span> hash&lt;H&gt;(&amp;<span class="kw">self</span>, state: &amp;<span class="kw">mut</span> H) <span class="kw">where</span> H: Hasher <span class="op">{</span></a>
<a class="sourceLine" id="cb18-18" data-line-number="18">        <span class="kw">self</span>.<span class="dv">0.</span>hash(state);</a>
<a class="sourceLine" id="cb18-19" data-line-number="19">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-20" data-line-number="20"><span class="op">}</span></a></code></pre></div>
<p>And then we can use these declassification policies to discern legal implementations of specific types as we’ve done before. Consider the type:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">fn</span>&lt;<span class="ot">&#39;a</span>, S&gt;(S, <span class="dt">u64</span>) -&gt; <span class="dt">bool</span> <span class="kw">where</span> S: Sec&lt;&amp;<span class="ot">&#39;a</span> <span class="dt">str</span>&gt; + <span class="bu">Hash</span></a></code></pre></div>
<p>We know that there are some trivial implementations (e.g. comparing the <code class="sourceCode rust"><span class="dt">u64</span></code> against <code class="sourceCode rust"><span class="dv">0</span></code>) that don’t make use of the secret value, but what about implementations that do? We can come up with something like:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">fn</span> check&lt;<span class="ot">&#39;a</span>, S&gt;(password: S, db_hash: <span class="dt">u64</span>) -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">where</span> S: Sec&lt;&amp;<span class="ot">&#39;a</span> <span class="dt">str</span>&gt; + <span class="bu">Hash</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    <span class="co">// please don&#39;t actually do this, use bcrypt or scrypt instead.</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="kw">use</span> std::collections::hash_map::DefaultHasher;</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="kw">let</span> <span class="kw">mut</span> hasher = DefaultHasher::new();</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    password.hash(&amp;<span class="kw">mut</span> hasher);</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    hasher.finish() == db_hash</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="op">}</span></a></code></pre></div>
<p>Now, if we connected this to a web framework (like the amazing <a href="https://rocket.rs/">Rocket</a>), we could imagine having our forms always providing passwords as secret values. Then, by using traits as declassification policies, we can use the type system to ensure that we never accidentally misuse the password. However, we should be wary: we used <code class="sourceCode rust"><span class="bu">Hash</span></code> in this example because it’s provided by <code class="sourceCode rust">std</code> and includes already-implemented hash algorithms, but it’s actually overly-permissive for this purpose. We could write a custom hasher that would allow us to leak information or even completely reveal the value. For a real implementation, we would instead provide a more constrained trait that allows you to compute a specific cryptographic hash such as bcrypt or scrypt.</p>
<h1 id="some-final-words">Some Final Words</h1>
<p>If you’ve made it this far, you’ve seen a bunch of “crazy academic concepts” like parametricity, free theorems, and noninterference. You’ve also seen how traits can be used to relax parametricity and give us even more useful free theorems. Hopefully, this endeavor has convinced you of the strength of type-based reasoning in Rust. The <a href="https://github.com/aatxe/reasoning-with-types">small examples</a> that you’ve seen throughout the post are really just scratching the surface of this kind of reasoning: we can go further by using the added constraints from the ownership system to produce even more interesting theorems (such as that a <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">cryptographic nonce</a> is only used once). The extent of these reasoning capabilities is one of my personal favorite features of strong type systems, and subsequently one of my favorite things about Rust. Maybe it’ll be one of yours now too!</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Owing to their presentation in the paper <a href="http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf"><em>Theorems for Free!</em></a>, these properties are known in the academic world as <em>free theorems</em>—though I suspect that some will be unhappy with my liberal application of this term to intuited properties.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>And indeed, it was originally presented as the <em>abstraction theorem</em> in John C. Reynolds’ <a href="http://www.cse.chalmers.se/edu/year/2010/course/DAT140_Types/Reynolds_typesabpara.pdf"><em>Types, abstraction, and parametric polymorphism</em></a>.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Actual Java does not allow the cast from <code class="sourceCode java"><span class="bu">Integer</span></code> to <code class="sourceCode java">T</code> as such, but there are more complicated examples involving subtyping that can produce similar specialized-by-type behavior. This simpler example nevertheless captures the essence of non-parametric functions.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Strictly speaking, <a href="https://cs.appstate.edu/~johannp/popl04.pdf">Haskell’s <code>seq</code> breaks general parametricity</a>, as do Rust’s various reflection capabilities (including <code>Sized</code>) and the upcoming <a href="https://github.com/rust-lang/rfcs/pull/1210">impl specialization</a> feature. Fortunately, like in the Haskell paper, we can always refine our notion of parametricity. Though this does have some consequences for precisely what properties you can glean from types.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>Though our argument is somewhat proofy, we would require a formal semantics for Rust. There exists one in the form of <a href="http://plv.mpi-sws.org/rustbelt/">RustBelt</a>, and as part of my research, I hope to produce an alternative formal backing for these free theorems in Rust, particularly the latter ones related to security.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>A connection between parametricity and noninterference was commonly held wisdom in the programming languages community, but was not proven until Bowman and Ahmed’s <a href="http://www.ccs.neu.edu/home/amal/papers/nifree.pdf"><em>Noninterference for Free</em></a>.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>The consequence of this is that we would need to define methods instead of operators which would make secret code look weirder and be less ergonomic, but is not a fundamental limitation to this approach. If the trait definitions were made more general, this would be a nonissue, and we could use macros instead to offer some improvements.<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>In <a href="https://hal.archives-ouvertes.fr/hal-01637023/document"><em>Type Abstraction for Relaxed Noninterference</em></a>, we see a related presentation of relaxed noninterference as a consequence of object-oriented type abstraction capabilities. Since Rust uses parametric polymorphism with traits for type abstraction, we are developing an analogue here.<a href="#fnref8" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Mon, 26 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html</guid>
    <dc:creator>Aaron Weiss</dc:creator>
</item>
<item>
    <title>Bridging the System Configuration Gap</title>
    <link>https://aaronweiss.us/posts/2017-06-05-bridging-the-system-configuration-gap.html</link>
    <description><![CDATA[<p>Last Friday, I gave a talk at <a href="http://www.nepls.org">NEPLS</a> on work I did while I was at UMass with <a href="https://people.cs.umass.edu/~arjun/home/">Arjun Guha</a>. You can find the slide deck for the talk <a href="/pubs/nepls17.pdf">here</a>, but the rest of this post will be a presentation of the same general material.</p>
<h1 id="the-state-of-system-configuration">The State of System Configuration</h1>
<p>In the past, system administrators relied largely on the shell to configure systems within an organization. Systems would either be configured manually on an individual basis, or automatically by scripts written by more enterprising administrators. However, the increased need for computer systems has made this approach generally intractable.</p>
<p>With the scale of modern computer systems, system configuration has become a pressing technical challenge. Large companies like <a href="http://redhat.com">Red Hat</a>, <a href="https://www.oracle.com/">Oracle</a>, and <a href="https://www.google.com/intl/en/about/">Google</a> are pouring money into configuration management tools to deal with these complexities. These tools provide powerful, high-level abstractions to make system administration easier, and they’re widely used for this purpose. For example, <a href="https://puppet.com">Puppet</a> boasts that it’s used by over 33,000 organizations, including 75 of the Fortune 100.</p>
<p>Still, scripts written in these configuration languages frequently contain bugs, and the shell remains the simplest way to diagnose them. However, after diagnosis, system administrators cannot <strong>fix</strong> the bugs from the shell as doing so would cause the state of the system to drift from the state specified by the configuration. Thus, in spite of their advantages, configuration management tools force system administrators to give up the simplicity and familiarity of the shell. But is there some way that we can fix this?</p>
<h1 id="bridging-the-gap">Bridging the Gap</h1>
<p>We’ve developed an approach called <em>imperative configuration repair</em> that uses techniques derived from general program synthesis to allow administrators to use configuration languages and the shell in harmony. With imperative configuration repair, a user can diagnose and repair a configuration bug via the shell and have the changes <strong>automatically</strong> propagate back to the original configuration. This propagation keeps the configuration in sync with the system, preventing <em>configuration drift</em>.</p>
<p>Imperative configuration repair has a number of important properties that make it particularly useful to system administrators. Firstly, it’s sound, meaning that all the changes made via the shell are preserved. Secondly, it supports configuration maintainability by preserving the structure and abstraction of the configuration. Thirdly, it deals nicely with the possibility of multiple repairs by presenting the user with a list of repairs ranked in a logical fashion. Finally, it works with all existing shells because it relies on known tools for programming monitoring (like <a href="https://linux.die.net/man/2/ptrace">ptrace</a>).</p>
<h1 id="a-repair-scenario">A Repair Scenario</h1>
<p>To get a better idea of what imperative configuration repair actually looks like, let’s step through an example from the perspective of <a href="http://www.piedpiper.com">Pied Piper</a> using <a href="https://puppet.com">Puppet</a>.</p>
<pre class="puppet"><code>package {&quot;apache2&quot;: ensure =&gt; present }
service {&quot;apache2&quot;: ensure =&gt; running }

define website($title, $root) {
  file {&quot;/etc/apache2/sites-enabled/$title.conf&quot;:
    content =&gt; &quot;&lt;VirtualHost $title:80&gt;
    DocumentRoot /var/sites/$root
    &lt;/VirtualHost&gt;&quot;
  }

  file {&quot;/var/sites/$root&quot;:
    ensure =&gt; directory,
    source =&gt; &quot;puppet://sites/$root&quot;,
    mode =&gt; 0700,
    recurse =&gt; &quot;remote&quot;
  }
}

website {&quot;piedpiper.com&quot;: root =&gt; &quot;piedpiper&quot; }
website {&quot;piperchat.com&quot;: root =&gt; &quot;piperchat&quot; }</code></pre>
<p>In this example, we install and start the Apache service. We also create two simple Apache configurations that set up two websites, PiedPiper.com and PiperChat.com. This uses a type of Puppet abstraction known as a <em>define type</em>, but you can think of this as a simple function.</p>
<p>On its face, this Puppet configuration (or <em>manifest</em>) looks to be correct. However, when we deploy the configuration to a machine and try to visit either website, we get an Error 403: Forbidden. In order to debug this issue, we can then head to the shell. Looking at the log files (<code>tail /var/log/apache2/error.log</code>), we can see a line stating <code>permission denied</code>. We haven’t set up anything about user access, and so the problem should be one of filesystem permissions. When we run <code>stat /var/sites/piedpiper</code>, we get back that the owner is <code>root</code> and the permissions are <code>-rwx------</code> (or <code>0700</code> for short). From this, we can recognize the issue: our <code>www</code> user cannot access the files Apache is trying to serve!</p>
<p>Now that we’ve identified the issue, we can try to fix it. One possible fix is to run <code>chmod 755 /var/sites/piedpiper</code>. We can run this in the shell, and then run the special command <code>synth</code> to start the process of imperative configuration repair. This will automatically propagate the changes back to the manifest, resulting in the mode line changing to <code>mode =&gt; 0755</code>.</p>
<h1 id="multiple-repairs">Multiple Repairs</h1>
<p>To get a sense of how multiple repairs are handled with imperative configuration repair, we can look at a simple, but slightly contrived example with a single instantiation of a single abstraction.</p>
<pre class="puppet"><code>define dir($path) {
  file {$path:
    ensure =&gt; directory
  }
}

dir { path =&gt; &quot;/foo&quot; }</code></pre>
<p>In this example, we have a <code>dir</code> abstraction that creates a directory at the specified path, and a single instantiation for the path <code>&quot;/foo&quot;</code>. If we then use the command <code>mv /foo /bar</code>, there are actually two possible repairs that make this change. The obvious one changes the constant <code>&quot;/foo&quot;</code> to <code>&quot;/bar&quot;</code>, but the other one changes the use of <code>$path</code> on the second line to <code>&quot;/bar&quot;</code> meaning the abstraction ignores its parameter.</p>
<p>Both repairs are correct in that they preserve the changes made via the shell, but a user is likely to prefer the one that changes the parameters to the abstraction. We capture this intuition in a ranking algorithm. We calculate a cost for each repair that corresponds to the sum of the number of updates and the number of updates within an abstraction. This means that smaller updates and updates that make changes outside abstractions are preferred.</p>
<h1 id="bringing-the-shell-to-puppet">Bringing the Shell to Puppet</h1>
<p>We implemented a prototype of imperative configuration repair for Puppet which we called <a href="https://github.com/plasma-umass/Tortoise">Tortoise</a>. Our prototype is written in <a href="http://scala-lang.org">Scala</a>, and consists of around 3,300 lines of code. It’s built using <a href="https://linux.die.net/man/1/strace">strace</a> and <a href="http://rise4fun.com/z3">z3</a>. It has its limitations, but works on a set of thirteen real Puppet benchmarks from <a href="https://github.com">GitHub</a> used in prior work. To get a better sense of how it works, let’s step through the whole toolchain at a high level.</p>
<p>The user starts a Tortoise monitor on a shell using its pid: <code>tortoise watch -i manifest.pp -p pid</code>. The user must specify which manifest is deployed on the system and should be updated according to the edits made. They then enter a number of commands on the shell which produce file system effects via system calls. Tortoise records these effectful system calls and the paths that they’ve affected. When the user has fixed the bug, they run the command <code>synth</code> to signal to Tortoise to generate the repair.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> After receiving the <code>synth</code> command, the process of imperative configuration repair begins.</p>
<p>Once initiated, Tortoise starts by parsing the manifest identified by the <code>-i</code> flag into a Puppet abstract syntax tree (AST). Then, it performs a labeling operation on the AST that assigns a unique label to each variable binding (including in abstractions). These labels are used to associate repairs with their corresponding bindings. We then compile the Puppet manifest into an imperative specification language called ΔP. This ΔP specification captures a series of file system operations and is used to generate a corresponding abstract file system on which the changes recorded by strace can be replayed. After replaying these changes, we can then use the abstract file system to produce ΔP constraints that will be used next in the synthesis procedure.</p>
<p>The synthesis procedure starts by compiling the ΔP specification into logical formulas describing the step-by-step operation of the manifest over a symbolic file system. It then converts the ΔP constraints into logical assertions about the final state of the program over the symbolic file system. Because these changes were made via the shell after running the program, they may currently be false. Next, <a href="http://rise4fun.com/z3">z3</a> is asked to repeatedly find new models for the repair by replacing values present in the original program. Each of these models are recorded, and parsed into repair substitutions. These repairs are then ranked by the previously described ranking algorithm, and presented to the user. The user then selects their preferred repair, and the system automatically applies it to the manifest on disk.</p>
<h1 id="evaluating-tortoise">Evaluating Tortoise</h1>
<p>We evaluated our prototype on a suite of thirteen real world Puppet benchmarks that were gathered from GitHub. These benchmarks consist of instantiations of open source Puppet modules. For each benchmark, we identified a number of possible repairs to make via the shell. We ran Tortoise with each benchmark and each shell repair, and produced a list of repairs. To understand the effectiveness of the ranking procedure, we presented this list in a randomized fashion and asked the user to select their preferred repair. We recorded the Tortoise-assigned rank of this repair for each instance. We then averaged them and found that the average repair rank was 1.31 indicating that Tortoise typically ranks the preferred repair as the first option (this exact case occurred 75% of the time).</p>
<figure>
<img src="/images/size-scaling.png" alt="Varying manifest size with a constant-sized update." /><figcaption>Varying manifest size with a constant-sized update.</figcaption>
</figure>
<p>We also looked at evaluating the scalability of Tortoise on artificial benchmarks. In each case, we ran 100 trials at each size, recorded the runtime, and computed the average and confidence interval across all trials. In one case, we looked at varying the size of the manifest while leaving the update size constant. This result is presented above. In practice, most manifests do not seem to grow beyond this size and the performance is well under a second. So, this performance seems reasonable.</p>
<p>In the other case, we looked at varying the size of the update. This result is presented below, and appears roughly exponential. This is expected because Tortoise relies on SMT solving to generate repairs. Fortunately, we can break up large repairs into a series of smaller intermediate pieces (that cover some part of the overall repair) and avoid the degenerate performance at large sizes. In general, we expect that users will likely perform distinct updates separately anyway.</p>
<figure>
<img src="/images/update-scaling.png" alt="Varying update size for a manifest." /><figcaption>Varying update size for a manifest.</figcaption>
</figure>
<h1 id="summary">Summary</h1>
<p>In conclusion, we presented imperative configuration repair and a prototype <a href="https://github.com/plasma-umass/Tortoise">Tortoise</a> that together bridge the gap between configuration management tools and the shell. Imperative configuration repair preserves all changes made from the shell, preserves the structure and abstractions of the original manifest, and uses instrumentation techniques to support all existing shells. Our prototype implementation is fast, and shows that our ranking algorithm appears reasonable. Overall, we have demonstrated that imperative configuration repair is a realistic technique for improving the process of configuration management.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Currently, <code>synth</code> is just an alias of the Unix <code>true</code>. A future version of Tortoise will instead have a dedicated <code>synth</code> program that communicates with the Tortoise monitor and presents the choice of repairs in this shell, rather than the monitoring one.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Mon, 05 Jun 2017 00:00:00 UT</pubDate>
    <guid>https://aaronweiss.us/posts/2017-06-05-bridging-the-system-configuration-gap.html</guid>
    <dc:creator>Aaron Weiss</dc:creator>
</item>
<item>
    <title>A Brief History of Pdgn</title>
    <link>https://aaronweiss.us/posts/2015-02-11-history-of-pdgn.html</link>
    <description><![CDATA[<p>This is a cross-post from the <a href="http://blog.pdgn.co">PdgnCo Community Blog</a>. It was published on February 11th, 2015, and can also be found <a href="http://blog.pdgn.co/general/2015/02/11/history-of-pdgn.html">here</a>.</p>
<hr />
<p>The idea for Pdgn first came in June of 2014. For reasons that I can’t recall, I was drawn to searching for a domain. I didn’t really have a purpose for it. I was just poking around to see if anything cool was available. I stumbled upon the domain <code>pdgn.co</code>, and I thought it was concise, oddly charming, and easily pronouncable (as the English word, pigeon). As I said, I didn’t have a purpose, and so, I didn’t purchase the domain. I did, however, keep it in my mind.</p>
<p>Around this time, my productivity levels had plummetted immensely. I had begun to loathe working in Java, and my constant attempts to take on incredibly large projects were going nowhere. I’d been trying to learn Haskell on-and-off for roughly a year, and I’d fallen completely in love with functional programming as a paradigm. In another IRC network that I call home (<a href="http://www.fyrechat.net">FyreChat</a>), I’d also been exposed to Rust. I didn’t really think of myself as capable of programming in a systems language, but I liked that Rust had many of the nice idioms that I had come to appreciate from my struggles with Haskell. So, I wanted to jump ship from Java, and I was looking at both Rust and Haskell. However, I didn’t have any ideas of reasonable things to work on once I did. That changed in July.</p>
<p>In July of that year, as the next step in a big push to distance myself from Google, I had decided that I wanted to run a small, privacy-first email service and that I wanted to write all the software myself. I had some experience with IRC as a protocol, and I figured that the email protocols couldn’t be that much worse. So, I bought the domain. I tried to make the decision of whether I wanted to write it in Rust or Haskell. Rust would be hard because I was scared of the idea of having to manage memory myself, and Haskell would be hard because I was still struggling to understand how to work with state and the real world. Ultimately, at the urging of some friends, I decided that I would write the service in Rust. I also decided that I may as well combine it with a privacy-first chat service as well. My goal was to incorporate the best privacy practices available for existing protocols, and thus I wasn’t going to invent a new chat client or a new email protocol and so on.</p>
<p>Still, even with an idea, my motivation was pretty low. I looked at the task of learning a new language as an impossibly high barrier, and much like previous projects, I worried that it was too large of a task for me to finish. Having already assured some of my friends that it would happen, I continually put off the idea and then put it off again. By the time summer ended, I had made no progress at all on my goal, and had made no effort to learn Rust. My friend <a href="http://www.jacobedelman.com">Jacob</a> bugged me countless times about writing the service because he wanted a new email address himself, but even that had done nothing to drive progress.</p>
<p>I was about to start University, and I stopped to look back at what I had done on the summer. When I did, I was saddened to see that I had done just about nothing and I wondered why. I wrote a <a href="http://aaronweiss.us/posts/2014-08-26-summers-gone.html">blog post</a> about it, and decided that I needed to do things differently. So when I started school, I decided that I was going to learn Rust by working with something familiar before doing anything unfamiliar. Dungeons and Dragons, 5th Edition was released around this time, and I wanted to play it with people over IRC. So, I thought that it would be a good opportunity to write an IRC bot to run the game. There was a clear path to starting off small, and a clear path for it to be more complicated. So, it seemed like a great first project. I split the project into two parts, <a href="https://github.com/aatxe/irc">the IRC library</a> and <a href="https://github.com/aatxe/dnd">the bot</a> itself, and I set off to learn Rust.</p>
<p>From September 10th on, I was throwing all the free time that I could muster into this bot. Bored in my data structures class, I started using that time to work on it, too. Once I got over the hump of struggling with the language (and especially lifetimes), I started making good progress. I knocked out a lot of the features I had planned, and by the end of October, I found myself looking mostly at some of the harder stuff. I wanted to implement a battle map, and that required an associated web server component. I was worried about how hard it was going to be, and so I went looking elsewhere for places to continue my learning of Rust. Eventually, it occurred to me that a part of my goal had been to run an IRC server in Rust. I obviously couldn’t write it immediately, but I could definitely launch a server with an existing IRCd and make it a long-term project.</p>
<p>With that, on October 27th, 2014, Pdgn as an IRC network was born. I reached out to my high school friends Jacob and Alok, and asked them to join. We had run an online computer science competition earlier in the year (<a href="http://hsctf.com">HSCTF</a>), and I had missed being able to interact with them over IRC. In what can only be described as perfect timing, <a href="https://picoctf.com">PicoCTF</a> had also started that day. This meant that Jacob and Alok, both participating in it, were immediately in contact with many of the participants of HSCTF who spent their time in our IRC channel on Mibbit during and after the competition. The channel had all but completely disappated by this time, and so I hadn’t really heard from any of them. They both took this as an opportunity to recruit, and they convinced a number of old friends (and former HSCTF participants) to join the network. Slowly, but surely, we garnered a small userbase.</p>
<p>Seeing all the progress that was made in a day, I immediately started work on our own set of IRC services written in Rust. I didn’t have a lot of knowledge about how they were implemented, and so, I assumed that they were just normal bots. For anyone looking to not replicate my mistake, services are almost always implemented as a separate server linked to the main hub. Regardless, I carried on blindly. Within two days, nickname and channel registration was implemented. The services were starting to shape up, and I was excited to be putting them to immediate use. One issue I encountered along the way was that the user mode marking that you’re identified (<code>+R</code>) is actually only able to be set by a server. I didn’t have a server component to my IRC library, and I knew that that would be a huge investment. So, I modified the <code>m_samode</code> module for InspIRCd to allow operators to set the mode <code>+R</code> with the <code>SAMODE</code> command. I was the only server operator, and so I figured that it wouldn’t be much of an issue. With that, the bot was able to mark people as being identified.</p>
<p>A few days later, I found myself joining a discussion on the Mozilla IRC about IRC libraries in Rust. As far as I knew, my library was the only one that built on the latest Rust, as many of the previous developers had abandoned their work. While my library worked fine for my purposes, others were critical of my use of callbacks to define IRC functionality. Another developer who had previously worked on an IRC library pointed me in the direction of a better design. They recommended that I take advantage of iterators because of all of the sugar associated with them in Rust. So, <a href="https://github.com/aatxe/irc/tree/91aa5bcc6f5a2380bb2348274432b34d86b03ace">on November 2nd</a>, I did a large refactor of my IRC library. I dropped a lot of the excess, and implemented an iterator-based design. From there, I started down a long path of improving the library. I wrote a collection of utility functions that evolved into a utility wrapper to the server objects. I rewrote tons of unit tests. I added SSL support, and working user tracking with access level support. I dealt with crate name squatting on the Rust <a href="https://crates.io">crate repository</a>, and eventually claimed the crate name <code>irc</code>. I made the library thread-safe, and fully specification compliant. The library grew into something substantial, and I was happy for it.</p>
<p>Both bots weathered the storm of the redesign, and while the Dungeons and Dragons bot had stagnated, the services bot continued to grow and expand. At Jacob’s urging, I implemented the game <a href="https://en.wikipedia.org/wiki/The_Resistance_(game)">Resistance</a> as an optional feature for it. I also added a counter to track stupid mistakes, and a full-featured voting-based administration tool. The idea was to use the bot (named Pidgey, and declared our mascot) to allow fully democratic channel administration. We found out quickly that this was less than desirable. People started lots of non-sense votes, and rarely did votes ever pass. Eventually, I retired the democracy feature, and Pidgey went back to just managing channel and nickname registration (with Resistance and derps on the side). The server kept on running.</p>
<p>After a few months, it became more apparent that running an IRC network on a single server was less than desirable. I wasn’t able to do updates of any kind, and maintenance meant that everything was completely inaccessible. So, I set out to make Pdgn into an actual network instead. The first step was to <a href="http://aaronweiss.us/posts/2015-02-03-going-static.html">move my site off of Ghost</a>, which was being hosted on the same server as the IRC network. Once that was done, I got two new, smaller servers for the network. One in San Fransisco, and one in New York. I had to decide on names, and I wanted an overarching theme for them. So, I settled on <a href="http://dictionary.reference.com/browse/genus">genera</a> of pigeons as an appropriate name. The hub server in New York was named <a href="https://en.wikipedia.org/wiki/Columba_(genus)">Columba</a>, after the genus of typical Old World pigeons. The server in San Fransisco was named <a href="https://en.wikipedia.org/wiki/Dodo">Raphus</a>, after the genus of the dodo (which is, to some people’s suprise including my own, a type of pigeon!).</p>
<p>On February 3rd, 2015, both of the new servers went live, and the original server that housed Pdgn was taken down. With this, the original services bot was also retired. <a href="https://github.com/Pdgn/site/tree/fa533c0f976470211ca41f689c45001dd270ee67">On February 9th</a>, I released an official <a href="http://pdgn.co">pdgn.co site</a>, and then <a href="https://github.com/Pdgn/blog/tree/919e50226dd6e68e69ef85dda4c6ce73e72a6075">on February 10th</a>, I released the official <a href="http://blog.pdgn.co">pdgn.co community blog</a>. This brings us to today, February 11th, where I have now, for the first time, documented the history of the network. It’s hard to say where the future will take us, but I hope to expand the network with more servers and more people. This is really only the beginning.</p>]]></description>
    <pubDate>Wed, 11 Feb 2015 00:00:00 UT</pubDate>
    <guid>https://aaronweiss.us/posts/2015-02-11-history-of-pdgn.html</guid>
    <dc:creator>Aaron Weiss</dc:creator>
</item>
<item>
    <title>Worker Appreciation Day</title>
    <link>https://aaronweiss.us/posts/2014-10-21-worker-appreciation-day.html</link>
    <description><![CDATA[<p>As a member of the Student Labor Action Project, I wrote an opinion-editorial for UMass’ Daily Collegian. It was published October 30th, and is available online <a href="http://dailycollegian.com/2014/10/30/appreciating-campus-workers/">here</a>. Additionally, it is reproduced exactly as I wrote it below.</p>
<hr />
<p>Today is Worker Appreciation Day. The Student Labor Action Project (SLAP) is hosting a brunch to show gratitude to the many workers of UMass. We’d like to encourage other students to do their part in expressing their gratitude to those with whom they interact. Workers make UMass work. They clean our dishes, our floors, and our showers. They fix our heating, sell us books, and run the on-campus hotel. Perhaps most importantly, they make our food. Do we, as students, consider the significance that workers have in our everyday lives? Without UMass workers, we could not have the incredible experiences made available to us at this institution. So, what do they get in return?</p>
<p>The University of Massachusetts is one of the largest minimum wage employers in the state. Working a traditional 2,000-hour work-year at the minimum wage nets a whopping $16,000 per year. According to the <a href="http://aspe.hhs.gov/poverty/14poverty.cfm">Department of Health and Human Services</a>, the poverty line for a family of four is $23,850 per year. According to the <a href="https://web.archive.org/web/20140830112333/http://quickfacts.census.gov/qfd/states/25/2501360.html">United States Census Bureau</a>, Amherst Center has a poverty rate of 30.5%, roughly three times the state average of 11%. It’s no wonder roughly a third of the people living in Amherst and the surrounding towns are living below the poverty line. Given its size, our university has a profound impact on the areas surrounding it, but chooses to do the bare minimum to keep its workers out of poverty.</p>
<p>On top of this, the university keeps workers from their rightfully-deserved benefits, violating the spirit of a court ruling in 1979 (<a href="https://www.dropbox.com/s/jql67cos5zn3nni/Berwald%20v.%20Board%20of%20Trustees.pdf?dl=0">Berwald et al. v. The UMass Board of Trustees</a>). In the ruling, the court determined that it was unlawful for the university to keep workers serving a non-temporary function as a temporary, or 03, worker for more than one year. Yet thirty five years later, the university keeps long-time workers under this temporary designation by firing and rehiring them every year such that they never technically work long enough to warrant promotion under the terms of the ruling. As temporary workers, they are denied crucial benefits such as health and dental care.</p>
<p>The 03s fought back against this abuse in 2011 by unionizing. After three years of unionization, the 03s continue to work without contract as the university has kept them in a perpetual state of bargaining. As Ben Walton wrote earlier this year, continued bargaining has even been used by the administration to deny workers raises. Combined with inflation, the lives of essential workers are only getting harder, and they deserve better. As students of this institution, we pay a great deal of money and there’s no reason that those who feed us should not be able to feed themselves.</p>
<p>SLAP urges students to do their part in demanding economic justice for all UMass workers because they fundamentally shape our experience here and deserve far, far better than they have now. We need to band together in support of our workers; doing otherwise supports the status quo. We need their support, and right now, they need ours.</p>]]></description>
    <pubDate>Tue, 21 Oct 2014 00:00:00 UT</pubDate>
    <guid>https://aaronweiss.us/posts/2014-10-21-worker-appreciation-day.html</guid>
    <dc:creator>Aaron Weiss</dc:creator>
</item>
<item>
    <title>Write-Up: λ1</title>
    <link>https://aaronweiss.us/posts/2014-06-04-write-up-l1.html</link>
    <description><![CDATA[<p>As part of HSCTF, there was a reverse engineering problem entitled “λ1”. The problem text was short and to the point “Here’s the lock. Find the key.” The first phrase <a href="http://compete.hsctf.com/ciJsbu4VFk/%CE%BB1.zip">“Here’s the lock.”</a> linked to an archive containing three executables, one for each of the major operating systems. All three executables were 64-bit. This problem is the first of a series of reversing problems.</p>
<p>Ultimately, the goal of this problem was to retrieve the flag from one of the given executables. As a result, there’s a wide assortment of approaches to this problem. I’m not going to go over all of them here because I certainly don’t think I could produce all of them. Instead, I’m going to go over the approach that I anticipated as the most common solution to the problem. In fact, it’s possible that this wasn’t even the most common solution. Regardless, we’ll carry forward.</p>
<p>Recognizing that the problem is one of reverse engineering, my first reaction is to immediately fire up <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA</a>. Upon attempting to open the executable, IDA fails to do so because of the lambda in the file name. So, I rename it to <code>llama.exe</code> and try again to open it. This time, it works out. Next, I will attempt to run the program.</p>
<figure>
<img src="/images/L1-Screen1.png" alt="Running llama." /><figcaption>Running llama.</figcaption>
</figure>
<p>Upon entering input, I notice that the program quickly ends, but I can catch that the output of the program depends on the value I input. I also notice that when I enter non-numbers, the program outputs a parsing error before exiting. Therefore, I can assume that the input needs to be a number. Since the output changes based on the input and there’s no additional files included with these programs, I can assume that the information I’m looking for has to be stored in the executable in some form. So, let’s look at the string table.</p>
<figure>
<img src="/images/L1-Screen2.png" alt="Looking at the string table." /><figcaption>Looking at the string table.</figcaption>
</figure>
<p>Well, what’s this? It mentions GHC and RTS. If you didn’t know what these things were, a quick search on <a href="https://duckduckgo.com/?q=GHCRTS">DuckDuckGo</a> will reveal that GHC is the primary Haskell compiler and that the RTS is the Haskell runtime. Therefore, we now know that this is a Haskell executable made with GHC. As a result, we also know that the <code>.data</code> section is entirely runtime related data and that <code>.rodata</code> is going to hold actual variables from our program. After all, Haskell is an immutable language and as a result, data is read-only. So, let’s pull that up.</p>
<figure>
<img src="/images/L1-Screen3.png" alt="Looking at .rodata." /><figcaption>Looking at .rodata.</figcaption>
</figure>
<p>As it turns out, the first string in <code>.rodata</code> is a suspicious looking string and everything that follows it is denoted as being part of the base Haskell package. From this, we can infer that Haskell includes constants from the actual software as the first entry and then follows it with other strings from within <code>Prelude</code>. So, now, we need to figure out what to do with this string we found. Here it is: <code>Â°Â¥Â±Â¦Â¨Â¥Â·ÃƒÂ¥Â¶Â©ÃƒÂ¯Â­Â²Â«</code>.</p>
<p>Judging from some of the previous problems in HSCTF and the fact that the majority of the string consists of accented capital A characters, my first guess would be that it’s a Caesar cipher. After all, this suggests that there’s a pretty tight grouping in values. So, we’re going to have to build some sort of Caesar cipher solver to attempt this approach.</p>
<p>Here’s our Python script:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> shifter(s):</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">129</span>,<span class="dv">128</span>):</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">      <span class="bu">print</span>(i)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      <span class="bu">print</span>(<span class="kw">lambda</span> z,y: <span class="st">&quot;&quot;</span>.join(<span class="bu">map</span>(<span class="kw">lambda</span> x:<span class="bu">chr</span>((<span class="bu">ord</span>(x)<span class="op">+</span>y)<span class="op">%</span><span class="dv">256</span>),z)))(s,i)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="cf">except</span>:</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">      <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">shifter(<span class="st">&quot;</span><span class="ch">\xb0\xa5\xb1\xa6\xa8\xa5\xb7\xc3\xa5\xb6\xa9\xc3\xaf\xad\xb2\xab</span><span class="st">&quot;</span>)</a></code></pre></div>
<p>The script works by going over all possible shifts within a byte and outputting our input string shifted by each amount. For the actual input, you’ll see that we had to use an ASCII table to convert the string into a format that Python could handle. This step may be optional depending on the language used for this part of the problem. Once this is done, let’s explore the output.</p>
<figure>
<img src="/images/L1-Screen4.png" alt="Output from shifter." /><figcaption>Output from shifter.</figcaption>
</figure>
<p>Well, look at that. We searched through the input a little and we found something very, very suspicious. This string, <code>LAMBDAS_ARE_KING</code>, looks like it could be the key. In fact, it is indeed the key. We did it!</p>]]></description>
    <pubDate>Wed, 04 Jun 2014 00:00:00 UT</pubDate>
    <guid>https://aaronweiss.us/posts/2014-06-04-write-up-l1.html</guid>
    <dc:creator>Aaron Weiss</dc:creator>
</item>
<item>
    <title>Write-Up: awe</title>
    <link>https://aaronweiss.us/posts/2014-05-26-write-up-awe.html</link>
    <description><![CDATA[<p>As part of HSCTF, there was a reconnaissance problem entitled awe. The given text for the problem was simple, and generally unhelpful as it was part of a series on some of our organizers. The text read “My name is Aaron Weiss.” The problem was, as you could probably tell, about me.</p>
<p>The task of finding the flag was broken up into two pairs of <code>#, word</code> in two different places on the web. The hope was that when all four parts (two pairs from two sources) were found, they could be assembled into the flag using the order from the numbers accompanying the words. The format was designed purposefully to look suspicious and to draw attention across the web. The problem never intended for people to just guess random pieces of information.</p>
<p>The first pair was found in two GitHub repositories, <a href="https://github.com/aatxe/dc-anchor/commit/fdf059c097e1f2fbe5d988dd2fca74e1e984857b#L13">dc-anchor</a> and <a href="https://github.com/aatxe/juicebot/commit/31c8e338d1b939f79c413ded9bae31b0a8013e10#L2">juicebot</a>. As something of a gotcha, the first repository had another <a href="https://github.com/aatxe/dc-anchor/commit/6591b8d28ce6f6c3c626babdcf1c9b357182a317#L13">commit</a> wherein I had removed a flag from an old CTF we ran. Many teams got caught up thinking this was important, even despite the note I added saying it wasn’t. This probably helped to add to the confusion, as this old flag was found by a great many participants.</p>
<p>The other two pieces were found on the <a href="http://www.fyrechat.net">FyreChat IRC Network</a>. The first one was found in the channel description of the channel <code>#awe</code>. This could be found by using the command <code>/msg ChanServ LIST *</code> and reading through the results. It was actually the first result. Then, upon joining the channel, the topic was set with the remaining piece. Many teams found this last part by doing <code>/whois awe</code> and joining all of the channels I was in. This approach cheated them out of the channel description, and ultimately complicated the problem.</p>
<p>Once all the parts were found, the key could then be formed. Any combination that featured the words in the proper order, regardless of separators, would be considered correct. Valid keys could’ve been <code>aweiskindanew</code> or <code>awe is kinda new</code> or anything else to that effect. That would all suffice.</p>
<p>Many teams got caught up in searching for particular information about me and making guesses based on that information. This resulted in a variety of funny submissions that were all generally unrelated to me. Many of these submissions were related to an Iraq war veteran and a video wherein he challenged New York’s SAFE Act. Others were related to a seemingly insignificant secondary character in a book entitled the Trikon Deception. Here’s a sampling of some of the submissions: <code>2nd Amendment</code>, <code>awe is really cool</code>, <code>SAFE Act</code>, <code>My right is greater than your dead</code>, and <code>Gun Control</code>.</p>
<p>Based on the history of the problem, it should be rather apparent that it was a lot harder than it originally seemed to me as the author. The problem was originally set to be a 300 point problem, but was raised to a 400 point problem prior to the competition. Half way through the competition, the problem remained unsolved and so it was raised to 500 points. Ultimately, the problem was not solved during the competition.</p>]]></description>
    <pubDate>Mon, 26 May 2014 00:00:00 UT</pubDate>
    <guid>https://aaronweiss.us/posts/2014-05-26-write-up-awe.html</guid>
    <dc:creator>Aaron Weiss</dc:creator>
</item>
<item>
    <title>HSCTF Write-Ups</title>
    <link>https://aaronweiss.us/posts/2014-05-26-hsctf-write-ups.html</link>
    <description><![CDATA[<p>As an organizer of the recent High School CTF competition, <a href="http://hsctf.com/">HSCTF</a>, I designed a series of problems for competitors to take part in. My primary focus in problem design for the competition was in reverse engineering, but I also created one of the most challenging reconnaissance problem we offered in the competition. Since the competition is now complete, I’ll be posting a series of write-ups on the problems I designed. In each write-up, I’ll discuss the problem, the ideas that went into the design, the solution, pitfalls that users fell into, and any other interesting information about the problem.</p>
<p>The competition itself was wildly successful with over 750 teams registered, and over 2,100 participants. We offered 45 problems (and a survey) coming to a total of 14,250 points (50 points for the survey). We had a highly competitive top fifty with many teams able to jump quickly in the ranks by solving one problem. It was a close competition for sure. In fact, Raelly didn’t jump into the first position until the closing hour or two of the competition.</p>
<p>With that, I’d like to congratulate all of our participants in HSCTF. This was a wonderful competition and I’m deeply pleased with how well it went. Hard problems were solved. The competition was fierce. Everyone did a wonderful job. Specifically, I’d like to congratulate The Lumberjacks from Phillips Academy for placing third, 0x90.avi from Thomas Jefferson High School for placing second, and Raelly from Thomas Jefferson High School for Science and Technology for their last-minute steal of first place. This is especially impressive since they joined the competition rather late. Well played, everyone!</p>]]></description>
    <pubDate>Mon, 26 May 2014 00:00:00 UT</pubDate>
    <guid>https://aaronweiss.us/posts/2014-05-26-hsctf-write-ups.html</guid>
    <dc:creator>Aaron Weiss</dc:creator>
</item>

    </channel>
</rss>
